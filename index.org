#+TITLE: Ting Teodor tenker
#+AUTHOR: Teodor Heggelund
#+LANGUAGE: nb_no
#+OPTIONS: toc:nil num:nil html-postamble:nil

* Velkommen!

Teodor, /2017-01-16/.

Hei! Jeg heter Teodor. Trivelig at du vil lese hva jeg har skrevet!

Tanker bak å ha en blogg:
- Det kan være en god idé å sette seg ned for å tenke grundig gjennom noe, til
  den grad at det er nyttig for andre
- Noen ideer må bare ned med en gang, ellers blir de borte
- Gamle ideer kan være nyttige
- ... og ved alt alt sammen er helt åpent, bør jeg da inderlig gjøre en OK jobb
  -- ellers 

Jeg svarer på elektronisk post sendt til fornavn punktum etternavn på domenet
Google bruker til elektronisk post.

Så hva kan du forvente å se her? ... alt er filosofi. Så du kan kalle dette en
filosofiblogg? Nja. Ikke fryktelig nyttig. Så er alt annet. Da gir det ikke
særlig mye informasjon. Noen temaer som går igjen:
- *Epistemologi*. Hva vet vi? Hva vet vi ikke?
- *Systemer*. Hvordan henger ting sammen? Utvikling blir ofte kalt
  /system/utvikling, ikke helt uten grunn. Systemteori er også spennende.
  Hvordan oppfører ting seg når det er satt i system?
- *Utvikling*. Jepp, jeg er utvikler, jess, jeg ser verden gjennom en utviklers
  øyne. Sikkert også en del her som ikke er direkte relatert til utvikling.

* Abstraher ved behov, ikke før

Teodor, /2017-01-16/.

Abstraksjoner er herlig. Det fyller meg med en god, varm følelse når jeg
introduserer en god abstraksjon som gjør problemet lettere, og bedre å jobbe
videre. Og gode, varme følelser er fint, eller hva?

Noen ganger skal man ikke abstrahere. For eksempel før man har forstått
problemet. Hvilket problem prøver jeg å løse med blogg? Hvilken motor skal jeg
velge? Vet ikke. Har ikke forutsetning til å vite før jeg har produsert innhold.
Strategi? Produser innhold /først/, abstraher ved behov. (Analogt: programmer
/først/, abstraher ved behov.)

Obs obs: En abstraksjon som går lekk (hurr durr norsk, "Leaky abstraction") har
en grusom effekt på tredjepart som ønsker å bruke koden uten å forstå hver
enkelt lille bit. En lekk abstraksjon er dog ofte et steg mot å lage en tett
abstraksjon. Her er det også en skala; "alle abstraksjoner lekker"; men de som
holder i de fleste tilfeller og gir mer glede enn pine er ofte fine.

Jeg klarer iblant å programmere en løsning før jeg begynner å tenke på mulige
abstraksjoner. Det gir ofte fin kode. Er det muilg med en blogg? [[http://www.paulgraham.com][Paul Graham]]
har en blog jeg liker, som er helt uten superfancy ting. Dette ville jeg prøve.

Denne bloggen er ett dokument i org-mode som jeg kompilerer til HTML med den
innebygde eksport-funksjonen.

Noen fordeler:
- Kompileringsprosessen er "umiddelbar"
- Lasting av nettsiden er "umiddelbar"
- Ukomplisert. Ingen komponenter jeg ikke forstår -- jeg har full kontroll.

Andre ting jeg liker med prosessen:
- Jeg kan redigere i Org-mode. Org-mode er det nærmeste jeg har kommet slik
  redigering av tekstdokumenter bør gjøres. Her en en [[https://www.youtube.com/watch?v=SzA2YODtgK4][introduksjonsvideo]] til
  org-mode.

* Hva er rett abstraksjon?                                         :noexport:

Egenvektorer? Ortogonalitet? Er abstraksjonen din i rett koordinatsystem? Er
aksene vinkelrette? Sjekk 

* Teknologi og tema                                                :noexport:

- Innhold i Org. Søkbart, sammenliknbart, tilgjengelig
- Presentasjon med minimalt tema
- TOC til venstre?
  - Ideelt: implementere Org-navigasjon + hjkl i treet.

* Når ikke lenger en person skal gjøre alt                         :noexport:

Delegering er vaaanskelig:

- Ting blir bra fordi du jobber hard med detaljer
- Om du "jobber hard med detaljer når du delegerer" vil du drive personene som
  jobber med deg fra vettet.
  - De gjør en dårligere jobb,
  - Tar ikke ansvar,
  - Tar ikke initiativ
  - ... og du er fremdeles tynget med mental last.

Intenst ansvar kan gjøre at resultatet blir bra. Det kan også forhindre andre i
å ønske å bidra.

Utfordring: dele på arbeidet med Elm-kurset. Ser bra ut! Var vanskelig først,
lettere etter hvert. Lettere å komme inn når noe er litt gjennomtenkt og man har
noen referanser. Tror det gjelder de andre på teamet.

Følelsesmessig: Å ikke lenger ha kontroll. Å delegere er å miste kontroll, /med
vilje/. Hvem ved sine fulle fem går med på noe sånt???

Nå er folk litt forskjellige på denne biten. Noen har null problemer med å
delegere, fordi de ganske enkelt ikke bryr seg. "Ditt ansvar, dust.". Andre har
svære problemer med å delegere fordi de ikke klarer å gi slipp på ansvaret.

Merk: noen ganger må man hoppe i det uten å ha kontroll. Andre ganger er det en
helt tullete avgjørelse å slippe styringen, og man får krise når ting kunne gått
bra.

* Typer eller ikke?                                                :noexport:

Typer er en mulighet for en /meget tett/ feedbackløkke. Denne sikrer konsistens,
og bidrar til kohesjon og arkitektur.

Fjernes typer, får man mulihet til å designe et friere språk. Jeg er særlig fan
av Clojure sin HTML-DSL, som er mer behagelig å skrive enn HTML i seg selv.

(Elm gjør et spennende forsøk, og Haskell/halogen er heller ikke verst å
bruke).

Clojure: 

* Lærbare grensesnitt                                              :noexport:

Bret victor. Mye å hente her?

Gode grensesnitt er lærbare. De eksponerer sin egen mekanikk og oppgave, og lar
brukeren lære hva som gjelder av kausalitet for det aktuelle problemet. Gode
grensesnitt lærer i tillegg brukeren om /problemet/.

Lærbar programmering? Læringsdreven programmering? La andre lære kildekoden din?
Dokumentajonen skal være en prosess til å forstå resten.

Litt forskjellige vinklinger:
- Et lærbart grensesnitt er et grensesnitt hvor brukeren automatisk lærer
  hvordan han kan bruke det uten store steiner i veien.
  - Kontinuerlig bruk gir kontinuerlig forbedring
  - Trenger ikke slå opp i ekstern dokuementasjon
  - Læringen flater ikke ut over tid selv om man ikke dypper laaangt ned i
    dokumentasjonen.
- En lærbar kodebase er
  - Mulig å komme i gang med relativt fort, ingen enorm inngangsterskel
  - Når du først er inne er det lett og naturlig å bli bedre, flinkere, lett å
    navigere
- Et lærbart miljø (lærbar kultur) gir deg
  - En mulighet til å bidra tidlig
  - Kontinuerlig introduksjon til nye temaer, konsepter og ellers taus kunnskap
  - Lar deg bidra tilbake (fold onto self) når du lærer noe, og denne kunnskapen
    blir igjen tilgjengelig for andre
    - Kontroll, frihet og lærbarhet: En wiki gir frihet og lærbarhet, ikke
      kontroll. Trenger rykte og fellesnevnere. Dust sier noe som er usant?
      Trekk diskusjonen inn i rett forum. Du kan ikke bare bestemme hvordan ting
      /er/, det må tas med relevante personer. Trekk info tilbake til "draft";
      sett state til "diskuteres, er uferdig".

(Notat: fiks "du" / "han" / "vedkommende" -- innfør gjerne konsistens i pronomen
her.

* La feedback drive utviklingen din                                :noexport:

eller "Hvilken feedbackløkke vil du ha"?

Feedback er den største driveren til læring. Vi lærer gjennom tilbakemelding.
Som kunnskapsarbeidere er dette vitalt. Vi sitter ikke og gjør én ting gjennom
livet, vi lærer stadig nye ting. Når du velger deg verktøy (teknologi) for å
løse en kunnskapsbasert utfordring bør derfor feedbackløkken du velger deg stå
sentralt i valget av verktøy (teknologi).

Jeg har i det syste hatt mye moro med live-programmering i Python. ~live-py~ er
en utvidelse til Eclipse og Emacs som kjører live-evaluering av kode mens du
programmerer. Og det går fort. Hvor ofte tester du koden din? Hvor ofte må du
tenke deg om for hva du egentlig får inn her, og hva du kan gjøre med det?
Live-py lar deg først definere hva du skal operere på av data, så får du se i
sanntid hvordan denne dataen snirkler seg gjennom programmet ditt.

~SPC m l~!

<<gif med live-py>>

Hva det egentlig er vi løser som utviklere er ikke alltid så godt definert. Jeg
jobber med styrkeanalyser, og er heldig her: Hvis svaret mitt er matematisk
korrekt, er det som regel nyttig. Innen mykere felt er problemet vanskeligere.
Vi vil tilføre verdi, hva nå enn det skulle si. Da er ikke lenger den
matematiske definisjonen særlig nyttig, men vi vil heller ha nærhet til
brukergrensesnittet vi lager. Figwheel gjør en veldig god jobb.

<<gif med Fighweel>>

~try-elm~ med unger er fantastisk.

Scratch fungerer på denne måten ut av boksen. Scratch er dessverre meget langt
fra hva vi må bruke av verktøy i hverdagene våres, og overgangen til teknologi
som faktisk kan løse det aktuelle problemet kan/vil bli smertefullt.

Abstrakte problemer er en annen sak. Typer. Feedback til hjernen? Å skrive ned
som å resonnere? Å definere problemet så det kan /sees/ er kraftfullt. Om du kan
skrive det ned i rett språk (Norsk, Matematikk, kode, tegninger, ...), vil det
hjelpe tankeprosessen i rett retning.

* Fryktdreven utvikling                                            :noexport:

Frykt gjør at du ikke tør å teste. Frykt gjør at du aldri får tilbakemelding.
Fryktdreven utvikling er antitesen til feedbackdreven utvikling. Redsel gjør at
vi ikke lærer. Redsel for å gjøre feil. Grusomt.

* Hva kan jeg?                                                     :noexport:

Tre ting jeg bryr meg om:
- Informasjonsteknolog :: Utvikling, programmeringsspråk, teknologier
- Sivilingeniør* :: Statikk, elementanalyse, likevekt, ikkelineariteter,
                   dimensjonering av stål og betong
- Undervisning :: Formidlingsevne; studentassistent, Lær Kidsa Koding

Kryssrelasjonene er særlig spennende. Lærbar programmering? Programmering for
sivilingeniører? Hvordan kan sivilingeniører lære programmering? Her føler jeg
potensial!

*Er fullt klar over at man kan få en sivilingeniørgrad uten mekanikk, men jeg
sliter med å finne et bedre uttrykk for kulturen for rasjonalitet, sannhet og
gode løsninger jeg ser i sivilingeniøren. Det er denne kulturen som interesserer
meg, ikke nødvendigvis momentdiagrammene eller likevektslikningene. "En
naturlovenes forekjemper i et samfunn av kaos"?

* "Folding onto itself"                                            :noexport:

Konsept med kraft. *Selvdreven feedback-loop*. Selvforsterkenede feedback-loop.
Selvforsterkende effekt. Resonnans. Kraften av frihet.

Eksempler:
Programmerere har mer potensial til "selvbretting" enn mange andre yrkesgrupper.
De har muligheten til å lage sitt eget miljø:

- Programmet du lager former hva som er mulig. Design utvikler seg til å kunne
  utrrykke ideer. Når du må gjøre noe tungvindt er det alltid mulig å gjøre det
  smartere. Du kan tilpasse miljøet ditt (kodebasen) til å være utvidbar i den
  retningen du ønsker.
- Byggsystem. Det trenger ikke, og bør ikke være manuell klikking involvert for
  prosedyrer relatert til hva du driver med. Skriver du byggsystemet ditt selv,
  kan du velge hvordan ting skal skje. Datamodellering -> prosedyremodellering
- Verktøy. Emacs er kjerneeksempelet. Du kan i tillegg til å modellere og
  videreutvikle (a) kodebase og (b) byggsystem; videreutvikle (c) editoren din.
  Sirkelen er full. Nær-religiøsitet er oppnådd.

Ingeniører er mer begrenset i hva de kan gjøre. Verktøyene som brukes er direkte
begrensende, og motvirker enhver form for selvbretting:

- Ting er de-facto engangs, gjør ditt-gjør datt. De prosedyrene det er mulig å
  modellere, er mulige /gjennom ekstra arbeid/. GUI-formatet på alt mulig ellers
  gjør det vanskelig å løse problemer én gang.
- Ting er skjult. Jeg har de facto ikke muligheten til å se hvordan ting
  fungerer, og kontrollere hvordan "ting skjer inni". Hvorfor ikke? Ingen god
  grunn.

  Kontraeksempel: abaqus ved bruk av inputfiler gir mer kontroll enn GUI. Det
  gir modularitet, og muligheten til å omorganisere, trekke ut felles logikk.
  Det er imidlertid ikke mulig å modellere /prosedyrer/. Disse er hardkodet.
  Lekse fra Unix.

Konseptet med bibliotek over rammeverk er nært beslektet. Parsec i Haskell er et
/bibliotek/ for parsing, og ikke et rammeverk, som lar brukeren /kombinere og
komponere/ en parser, i stedet for å kreve at paring skal gjøres *akkurat slik*.
Spacemacs sliter litt med at ting er for tett koblet. Det er vanskelig å forstå
helheten, selv om det er en meget god helhet. (Dette er ikke krass kritikk av
Spacemacs, men en anerkjennelse at læring av Spacemacs blir vanskelig. Det er
imidlertid /mulig/ å forstå hvordan det fungerer, gitt at man klatrer en
krevende læringskurve.)

* /Utfordrende/ læringskurve, ikke /bratt/ læringskurve            :noexport:

... eller bør vi bare si "krevende læringsprosess"?

Hva er en bratt læringskurve? For å svare på spørsmålet må vi vite aksene. Er en
læring og en tid? Er en nytte og en innsats? Hva er x og hva er y? Bruker alle
det feil?

La oss heller unngå problemet. Når vi snakker om læringskurve, er vi interessert
i den følelsesmessige prosessen rundt å læring av et tema. Dette kan vi beskrive
godt og konsist!

> Emacs har en krevende læringskurve
> Emacs har en læringskurve med skyhøyt takes

Lett å forstå, ikke sant?

Hva tenker jeg om "han som sa at Lisp bare er tull fordi det er vanskelig
("uleselig", "uhåndterbart") på YouTube? "Skriv om alt til Perl"?

- Enhver kodebase skrevet av én person kommer til å være bygget opp på en annen
  måte enn en kodebase skrevet i konsensus
- Fordel: stor grad av kohesjon
- Fordel: (kanskje) få feil
- Ulempe: stort krav til eksakt samme kompetanse som vedkommende har
- Ulempe: liten grad av tilbakemelding på lærbarhet

Felles kodebaser tvinges til å bli lærbare uten reimplementering.

* Grad av kjenthet                                                 :noexport:

Merk: Dette handler om konseptet ferdig/uferdig som skala; ikke om
"ferdigheter"; "ting du kjenner prosedyren for å gjøre".

Kunnskap er under kontinuerlig behandling. Det er viktig å vite hva som er
fastsatt, som man kan stole på, og hva som er uferdig.

Tradisjonell løsning:
- Sentral autoritet erklærer hva som er fakta
- Desentralisert miljø bidrar til "det som mangler" i en stor haug av kunnskap,
  hvor alt er uferdig som standard.

Dette skalerer ikke. Forslag:

- Alt er artikler.
- Artikler har en "ferdighetsgrad".
- Alt starter med "ferdighetsgrad" 0.
- Når vi reviderer, kan vi øke ferdighetsgrad.
- Hvem som kan promotere til hvilken ferdighetsgrad kan styres.
- Revisjoner øker ferdighetsgrad. Kjenthet? Prosent?

Vanskelig å sette kjenthet. Relativ kjenthet? 

Dropp kjenthet som et tall.
Kjenthet som skala:
Ukjent -- Vurdert -- Vurdert sterkt -- Kjent.
Konservativ.

Merk: det er meget vanskelig å si hvilken grad av kjenthet noe har. Men det kan
brukes til kommunikasjon. "Pass på å ikke gjøre for mye avhengig av dette; er
ennå ikke helt gjennomtenkt". Vanskelig grensesnitt mot ansvar. Vil ikke ta
ansvar for dette, så "sier bare at det er ukjent".

** Skal grad av kjenthet eksponeres?

Forskjellige personer har forskjellig behov til kjenthetsgrad. Bør alle trenge å
ta hensyn til dette? Når jeg skriver en tekst, skal jeg formulere meg sikkert på
kun det jeg anser som sikkert, eller skal jeg forutsette at leseren (som ofte
stemmer) er litt mindre interessert i den epistemologiske biten, og bare vil
kunne forutsette "det beste vi vet"?

Personlig: veldig mange bare skummer over og dropper usikkerhetsformuleringer.
Sier at "sånn er det, sånn skal det være". Vil sette agenda, sette virkelighet,
mutere andres oppfatninger. Siden dette er vanlig, er man ofte vant til å være
kritisk til andres påstander.

Kritisk formulering:
- Mer eksakt
- Mindre passende mot prosa-form
- Lite politisk, lite populistisk
- Blir ofte verbost. Teksten full av "kanskje", "trolig", "sannsynligvis",
  innholdet drukner lett

"Det går sikkert greit"-formulering:
- Bedre flyt i tekst
- Passer godt overens med annen prosa, tekst
- Se på hele teksten monadisk under usikkerhet? Konklusjonene underveis er
  basert på usikkerhet, returnerer noe som er litt mer usikkert?

#+BEGIN_SRC haskell
data Statement a = { ... }

instance Monad Statement where
  return = assert
  precondition >>= reasoning =
    let assumes = getAssumes precondition
        conclusion = reasoning assumes
    in  conclusion
#+END_SRC

/geeklevel veryhigh.

* Dokumenter som hierarkier                                        :noexport:

Sekvensielt dokument: prosa.
Hierarkisk dokuemnt: fakta. Kunnskapstre. Hvorfor i all verden kutter vi vekk
strukturen? Mulig å beholde denne og navigere med den!

Mer generelt: Kunnskapen vår er ca et tre, reelt en graf. I alle fall ikke en
liste! Bedre å bruke et tre til å representere enn en liste. Wikipedia er et
godt eksempel på kunnskap-som-graf. Lenker, diverse indekser. Konsepter er etter
ord (navn). Ved duplikater: lag indeks, referer. Hash-map: Etter hash. Ved
duplikater: lag lenket liste, populér "det under".

Org-mode gjør dette heeelt fantastisk. Så lesbart! Så navigerbart! Mååå bruke!
Vise! Dele! :D

Ting som er gjort fint:
1. Synlig dokumenthierarki, forståelig
2. Semantisk betydning av hierarki, som gjør at koden kan refaktoreres
3. Plain-tekst-representasjon, så dokumentet kan være i versjonskontroll og
   redigeres (leses) av andre editorer
4. ... selv om org-mode i seg selv gjør dette meget mer behagelig automatiserte
   redigeringsverktøy som drar nytte av strukturen

* Informasjonsflyt i dokumenter                                    :noexport:

Hva er en +god+ behagelig måte å representere dokumenter på?

- Behagelig å skrive dokument
- Enkel kompilering, rask feedback på resultat
- Behagelig å lese dokumentet.

Som kan løses ved følgende:

- Skriv dokumentet i formatet du ønsker
- Sørg for at det finnes en skikkelig parser som kan gi deg dokumentet i en
  hierarisk datastruktur
- Skriv din egen eksport av datastrukturen

Lær av Pandoc (men Pandoc har i tillegg mange typer inpustruktur).

** Eksempel: Org-mode til HTML
1. Skriv i org-mode, som er behagelig
2. Bruk innebygget parser til å tolke dokument
3. Bruk innebygget HTML-generator til å lage noe en nettleser kan lese

Pluss: enkelt
Minus: én svær HTML-side som kan være problematisk å linke til og navigere i.

** Eksempel: Org-mode til JSON + viewer
1. Skriv i org-mode
2. Parse med Pandoc
3. Skriv ut JSON
   Bonus: Er ikke så alt for mye, så JSON bør holde fint.
4. Lag webapp for å tolke og søke rundt i JSON.
   F.eks. CLJS eller Elm. Søk, collapse, tree view.
   Trenger bare shift-tab for å toggle collapse all og tab for toogle collapse
   current.

* Overlegenhet                                                     :noexport:

"Jeg klarer ikke forklare dette".

Forutsetning: jeg har rett, du tar feil, du skjønner ennå ikke faktaen som er
inni hodet mitt. Stemmer dette? Bør det modereres? Hmm, spørs.

Om man i "dette" legger "dette som er i hodet mitt" er det uproblematisk. Hvis
"dette" betyr "denne etablerte faktaen", er saken en annen.

Filosofisk: Bør jeg forutsette at jeg har rett? Bør jeg anerkjenne at jeg
oprererer i en kontekst; en kontekst som kan være feil? Kanskje ikke?

* Strategi for bloggen                                             :noexport:

Bloggen fungerer som to ting:
- En tenketank med mildt kaos
- Et arkiv, et oppslagsverk, klart for andres oppmerksomhet

Merk: det er forskjellige grunner til ikke å dele informasjon:
1. For å skjule egne imperfeksjoner fra offentligheten
2. Som en anerkjennelse at informasjonen er uferdig, og per nå gir forventet
   netto negativ verdi til andre enn forfatteren (eller eventuelt et høyere
   krav; netto positiv verdi til 95 % av leserene)

Morsomt, var visst en skala dette også.

* JavaScript -- takk for all fisken                                :noexport:

Eller -- takk til Javascriptutviklere, som har grepet dagen og gjort verden
bedre.

Så vi liker å fokusere på det som suger med JavaScript. Eller de gode bitene.
Her kommer et forsøk på å sette JavaScript i kontekst.

1. Funksjonell programmering

   Javascript har vært funksjonelt siden starten. Hadde vi hatt funksjonelle
   egenskaper i Java og C# i dag om det ikke var for JavaScript? Hadde
   funksjonelle språk blitt vurdert? Ville vi fått ting som LINQ?

   Det har vært forsøk på å få til dette siden 1960, og du klarte det.

   Takk.

2. Funksjonellreaktiv GUI-programmering

   Facebook: du gjør all verdens lugubre greier med dataene mine. Du blander
   sammen reklame og nettverk, og misbruker meg og mine venners rykte for å få
   oss til å forbruke mer.

   På den andre siden har du laget React. Ideen var gammel, men som dere
   gjennomførte den. Fantastisk førsteordenseffekt. De fleste
   javascriptutviklere kan i dag bruke et skikkelig fundament som håndterer
   avhengigheter i GUI. Takket være dere får brukere en genuint bedre
   opplevelse.

   Og sekundæreffektene! Både ideologisk og som en plattform. Ideologisk har
   dere økt den kollektive standarden for GUI-programmering.
   Meldingsbokssystemer som objekter kan gå og legge seg, og jeg trenger ikke
   akseptere å måtte jobbe med noe sånt igjen. Som plattform og bibliotek har
   dere tatt på dere men grandios arbeidsmengde med de grunnleggende
   byggesteinene. Elm og ClojureScript kan nå løse problemer i sine egne fine,
   isolerte domener, og dytte resultatet ned på dere -- fordi dere lagde React
   som et bibliotek, og ikke som et rammeverk.

   Takk.

3. Språklig frihet

   JavaScript gir enormt mye frihet, og betraktning som en plattform gir i mange
   tilfeller mer mening enn betraktning som et programmeringsspråk. Fordi
   språket legger særdeles få rammer for hvordan ting skal gjøres, har
   biblioteksutviklere fått meget stor frihet. De kan utforske hvordan ting bør
   gjøres. Hadde Javascript heller beveget seg i retning Java, og bare tillatt
   utviklere å gjøre det som i forkant ble betraktet som en strengt god idé,
   hadde plattformen stagnert.

   JavaScript er tidenes språklige R&D-operasjon. Friheten har dyttet ned
   ansvaret for utvikling på programmerere, og ikke språkdesignere. Dette mener
   jeg alt i alt er en god ting! Det har gitt oss fantastisk mange fine
   effekter, selv etter kostnader som en utfordrende læringsprosess og mange
   kaotiske kodebaser.

   Denne tankegangen speiler seg i Lisp-kulturen, særlig i Racket. Betyr det at
   vi heller burde hatt Racket i nettleseren? Nja. Da ville nok aldri alle de
   eksisterende utviklerene blitt med over på JavaScript. Det ser litt ut som
   Java, og fy som skinnet bedrar. Dere har kollektivt bedratt alle som har
   blitt med over på JavaScript-toget.

   Hva er så veien videre? Jeg mener bytecode er uungårlig. JavaScript behandles
   allerede i dag som bytecode av språk som Elm, Clojure, Haskell og PureScript.
   Og hvordan gjør det jobben? Særdeles bra! Ytelse er ofte bedre enn i
   originalspråket. Hva skjer da når vi kan kompilere til bytecode? Jeg er
   spent. Jeg gleder meg til å se WebAssembly komme på banen.

   Takk.

* Effektivitet vs kompleksitet                                     :noexport:

Dette er det uendelige problemet. Punkter:

- Hvilket nivå som er lønnsomt å legge seg på varierer fra person til person
- Høy kohesjon mellom personer gir gode muligheter til å dele kunnskap;
  informasjon; prosedyrer, gir økt potensiale for kommunikasjon
- Forskjellige personer løser forskjellige oppgaver på forskjellig vis. Det gir
  høyst forkjellige krav til effektivitet. Hva skal settes i system?
- Tidsbudsjett. 
  - Løse én gang nå. Legge inn en innsats nå, og gjøre ting mer effektivt seinere.
    - Legg grunnsteiner for systemet nå
    - Bygg forståelse av problemet underveis
    - Bygg muskelminne av problemet underveis
    - Videreutvikle når muskelminnet sitter og problemforståelsen er økt.
    - Aversjon mot ineffektivitet
    - Sier noe om /potensialet/ til et system. Minste felles multiplum?
  - Ta problemer som de kommer.
    - Vær avers mot å innføre nye systemer
    - Kjenn på smerte. Når noe gjør /skikkelig/ vondt, innfør systemet for å
      gjøre det mindre smertefullt.
    - Innfør system kun ved behov.
    - Aversjon mot kompleksitet og terskel
    - Sier noe om /grunnlinja/ til et system. Største felles divisor.

* Hvor dybt må du gå for å finne selvbretting?                     :noexport:

Grad av selvbretting synes et OK mål på grad av tilpasning; grad av kraft. La
oss prøve å evaluere noen verktøy i kontekst av selvbretting.

- Visual Studio: *3/10*. Lag ditt eget språk. Dog gode muligheter for key
  bindings. Sannsynligvis markroer på et eller annet nivå, men man må gjennom en
  masse menyer for å få tilgang. Menyene forhindrer frihet og selvbretting. Du
  kan ikke bruke editoren til å redigere menyene.
- Github Atom: *6/10*. Kan endre editoren i språket du bruker til å skrive programmet.
- Emacs: *10/10*. Editoren er kun et tynt skall over funksjonalitet. Ultimat selvbretting.
- Java: *5/10*. Kan lage egne prosedyrer og klassehierarkier. Arv kan være
  nyttig. Overloading av funksjonalitet i forskjellige objekter. Problematikk:
  svært verbost, må skrive mye for å få gjort noe. Funksjonsdeklarasjon er
  komplisert. Før Java 8 måtte man ha en klasse. Nå klarer man seg uten. Typer
  må ofte lages selv.
- C#: *6/10*. Litt mer fritt enn Java.
- Haskell: *8/10*. Konsist. Spennende potensial for DSL-er. Bruk av DSL-er
  typesjekker i språket. Implisitt typing gjør ting enda bedre.
- Python: *9/10*. Fullstendig frihet. Hva som følger med er ikke spesielt. Det
  er bare brukt litt vanskeligere deler av språket som man vanligvis ikke
  eksponeres for. Dekoratorer, metaklasser. Mulig å tilpasse til hva man trenger.
- Lisp: *10/10*. Det som følger med er en liiten kjerne. Resten kan tilpasses
  til hva man trenger. Rekursjon og funksjonsdeklarasjon er hakket mindre
  elegant enn i Haskell

* Presis eller implisitt?                                          :noexport:

"Korrekt eller behagelig?"

Tommelfingerregel: vær presis. Vær konsis.

Unntak: Noen ganger er implisitt kommunikasjon svært effektivt. Når begeret for
presis kommunikasjon er fylt, kan det fremdeles være noe igjen i den implisitte.

Programmering: /Du må være presis/. Ellers går det ikke.

Tekst som andre skal lese:
- Det er ofte smart å være presis
- Du kan ofte få ekstra mye ut av å bruke implisitte virkemidler
- Ekstra bonus: tenk på hvordan andre tenker på ting. Hvordan kan du gjøre denne
  tenkingen lettere? Bedre?

Eksempel: Blogger. Tematikken er sprikende. Hvis kategorisystemet vårt skulle
vært presist, hadde vi mistet hele mangfoldet, og mesteparten av de kule
tingene.

* Presentabel eller ren?                                           :noexport:

"Korrekt eller behagelig?"

Spennende hvor mange av disse innleggene som utforsker en kontrast?
Contrastcohere var kanskje ikke et så alt for dårlig navn, når alt kommer til
alt. Der er imidlertid på engelsk. Jeg liker å skrive på norsk.

Dagens kontrast: bør du optimalisere representasjonen for noe rent, generelt,
som kan være en fysisk lov; eller bør du gjøre det så behagelig å ta inn over
seg som mulig?

- Dokumenter du sender til andre skal være presentable.
- Dokumenter du skriver for egne formål, for å forstå hva du selv driver med,
  bør gjerne være presise.

Eller

- Kilden skal være presis
- Resultatet du leverer skal være presentabelt
