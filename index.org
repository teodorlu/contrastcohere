#+TITLE: Ting Teodor tenker
#+AUTHOR: Teodor Heggelund
#+LANGUAGE: nb_no
#+OPTIONS: toc:nil num:nil html-postamble:nil
#+EMAIL: teodor.heggelund@gmail.com

* Velkommen!

Hei! Jeg heter Teodor. Trivelig at du vil lese hva jeg har skrevet!

Tanker bak å ha en blogg:
- Det kan være en god idé å sette seg ned for å tenke grundig gjennom noe, til
  den grad at det er nyttig for andre
- Noen ideer må bare ned med en gang, ellers blir de borte
- Gamle ideer kan være nyttige
- ... og ved alt alt sammen er helt åpent, bør jeg da inderlig gjøre en OK jobb
  -- ellers 

* Abstraher ved behov, ikke før

Abstraksjoner er herlig. Det fyller meg med en god, varm følelse når jeg
introduserer en god abstraksjon som gjør problemet lettere, og bedre å jobbe
videre. Og gode, varme følelser er fint, eller hva?

Dette klarer jeg i blant gjøre når jeg programmerer. Er det muilg med en blogg?
Etter å lest mye fra [[http://www.paulgraham.com][Paul Graham]], ville jeg prøve.

Denne bloggen er ett dokument i org-mode som jeg kompilerer til HTML med den
innebygde eksport-funksjonen.

Noen fordeler:
- Dritkjapt; jeg oppfatter ikke at det tar tid.
- Ukomplisert. Ingen komponenter jeg ikke forstår -- jeg har full kontroll.

Andre ting jeg liker med prosessen:
- Jeg kan redigere i Org-mode. Org-mode er det nærmeste jeg har kommet slik
  redigering av tekstdokumenter bør gjøres. Her en en [[https://www.youtube.com/watch?v=SzA2YODtgK4][introduksjonsvideo]].

Teodor, /2017-01-16/.

* Teknologi og tema                                                :noexport:

- Innhold i Org. Søkbart, sammenliknbart, tilgjengelig
- Presentasjon med minimalt tema
- TOC til venstre?
  - Ideelt: implementere Org-navigasjon + hjkl i treet.

* Når ikke lenger en person skal gjøre alt                         :noexport:

Delegering er vaaanskelig:

- Ting blir bra fordi du jobber hard med detaljer
- Om du "jobber hard med detaljer når du delegerer" vil du drive personene som
  jobber med deg fra vettet.
  - De gjør en dårligere jobb,
  - Tar ikke ansvar,
  - Tar ikke initiativ
  - ... og du er fremdeles tynget med mental last.

Intenst ansvar kan gjøre at resultatet blir bra. Det kan også forhindre andre i
å ønske å bidra.

* Typer eller ikke?                                                :noexport:

Typer er en mulighet for en /meget tett/ feedbackløkke. Denne sikrer konsistens,
og bidrar til kohesjon og arkitektur.

Fjernes typer, får man mulihet til å designe et friere språk. Jeg er særlig fan
av Clojure sin HTML-DSL, som er mer behagelig å skrive enn HTML i seg selv.

(Elm gjør et spennende forsøk, og Haskelll/halogen er heller ikke verst å
bruke).

Clojure: 

* Lærbare grensesnitt                                              :noexport:

Bret victor. Mye å hente her?

Gode grensesnitt er lærbare. De eksponerer sin egen mekanikk og oppgave, og lar
brukeren lære hva som gjelder av kausalitet for det aktuelle problemet.

Lærbar programmering? Læringsdreven programmering? La andre lære kildekoden din?
Dokumentajonen skal være en prosess til å forstå resten.

Litt forskjellige vinklinger:
- Et lærbart grensesnitt er et grensesnitt hvor brukeren automatisk lærer
  hvordan han kan bruke det uten store steiner i veien.
  - Kontinuerlig bruk gir kontinuerlig forbedring
  - Trenger ikke slå opp i ekstern dokuementasjon
  - Flater ikke ut fordi han ikke har lest dokumentasjonen
- En lærbar kodebase er
  - Mulig å komme i gang med relativt fort, ingen enorm inngangsterskel
  - Når du først er inne
- Et lærbart miljø gir deg
  - En mulighet til å bidra tidlig
  - Kontinuerlig introduksjon til nye temaer, konsepter og ellers taus kunnskap
  - Lar deg bidra tilbake (fold onto self) når du lærer noe, og denne kunnskapen
    blir igjen tilgjengelig for andre
    - Kontroll, frihet og lærbarhet: En wiki gir frihet og lærbarhet, ikke
      kontroll. Trenger rykte og fellesnevnere. Dust sier noe som er usant?
      Trekk diskusjonen inn i rett forum. Du kan ikke bare bestemme hvordan ting
      /er/, det må tas med relevante personer. Trekk info tilbake til "draft";
      sett state til "diskuteres, er uferdig".

(Notat: fiks "du" / "han" / "vedkommende" -- innfør gjerne konsistens i pronomen
her.

* La feedback drive utviklingen din                                :noexport:

eller "Hvilken feedbackløkke vil du ha"?

Jeg har i det syste hatt mye moro med live-programmering i Python. ~live-py~ er
en utvidelse til Eclipse og Emacs som kjører live-evaluering av kode mens du
programmerer. Og det går fort. Hvor ofte tester du koden din? Hvor ofte må du
tenke deg om for hva du egentlig får inn her, og hva du kan gjøre med det?
Live-py lar deg først definere hva du skal operere på av data, så får du se i
sanntid hvordan denne dataen snirkler seg gjennom programmet ditt.

~SPC m l~!

<<gif med live-py>>

Hva det egentlig er vi løser som utviklere er ikke alltid så godt definert. Jeg
jobber med styrkeanalyser, og er heldig her: Hvis svaret mitt er matematisk
korrekt, er det som regel nyttig. Innen mykere felt er problemet vanskeligere.
Vi vil tilføre verdi, hva nå enn det skulle si. Da er ikke lenger den
matematiske definisjonen særlig nyttig, men vi vil heller ha nærhet til
brukergrensesnittet vi lager. Figwheel gjør en veldig god jobb.

<<gif med Fighweel>>

Abstrakte problemer er en annen sak. Typer.

* Fryktdreven utvikling                                            :noexport:

Frykt gjør at du ikke tør å teste. Frykt gjør at du aldri får tilbakemelding.
Fryktdreven utvikling er antitesen til feedbackdreven utvikling.

* Ferdigheter                                                      :noexport:

Tre ting jeg bryr meg om:
- Informasjonsteknolog :: Utvikling, programmeringsspråk, teknologier
- Sivilingeniør :: Statikk, elementanalyse, likevekt, ikkelineariteter,
                   dimensjonering av stål og betong
- Undervisning :: Formidlingsevne; studentassistent, Lær Kidsa Koding

* "Folding onto itself"                                            :noexport:

Konsept med kraft. *Selvdreven feedback-loop*. Selvforsterkenede feedback-loop.
Resonnans. Kraften av frihet.

Eksempler:
Programmerere har mer potensial til "selvbretting" enn mange andre yrkesgrupper.
De har muligheten til å lage sitt eget miljø:

- Programmet du lager former hva som er mulig. Design utvikler seg til å kunne
  utrrykke ideer. Når du må gjøre noe tungvindt er det alltid mulig å gjøre det
  smartere. Du kan tilpasse miljøet ditt (kodebasen) til å være utvidbar i den
  retningen du ønsker.
- Byggsystem. Det trenger ikke, og bør ikke være manuell klikking involvert for
  prosedyrer relatert til hva du driver med. Skriver du byggsystemet ditt selv,
  kan du velge hvordan ting skal skje. Datamodellering -> prosedyremodellering
- Verktøy. Emacs er kjerneeksempelet. Du kan i tillegg til å modellere og
  videreutvikle (a) kodebase og (b) byggsystem; videreutvikle (c) editoren din.
  Sirkelen er full. Nær-religiøsitet er oppnådd.

Ingeniører er mer begrenset i hva de kan gjøre. Verktøyene som brukes er direkte
begrensende, og motvirker enhver form for selvbretting:

- Ting er de-facto engangs, gjør ditt-gjør datt. De prosedyrene det er mulig å
  modellere, er mulige /gjennom ekstra arbeid/. GUI-formatet på alt mulig ellers
  gjør det vanskelig å løse problemer én gang.
- Ting er skjult. Jeg har de facto ikke muligheten til å se hvordan ting
  fungerer, og kontrollere hvordan "ting skjer inni". Hvorfor ikke? Ingen god
  grunn.

  Kontraeksempel: abaqus ved bruk av inputfiler gir mer kontroll enn GUI. Det
  gir modularitet, og muligheten til å omorganisere, trekke ut felles logikk.
  Det er imidlertid ikke mulig å modellere /prosedyrer/. Disse er hardkodet.
  Lekse fra Unix.

Konseptet med bibliotek over rammeverk er nært beslektet. Parsec i Haskell er et
/bibliotek/ for parsing, og ikke et rammeverk, som lar brukeren /kombinere og
komponere/ en parser, i stedet for å kreve at paring skal gjøres *akkurat slik*.
Spacemacs sliter litt med at ting er for tett koblet. Det er vanskelig å forstå
helheten, selv om det er en meget god helhet. (Dette er ikke krass kritikk av
Spacemacs, men en anerkjennelse at læring av Spacemacs blir vanskelig. Det er
imidlertid /mulig/ å forstå hvordan det fungerer, gitt at man klatrer en
krevende læringskurve.)

* /Utfordrende/ læringskurve, ikke /bratt/ læringskurve            :noexport:

Hva er en bratt læringskurve? For å svare på spørsmålet må vi vite aksene. Er en
læring og en tid? Er en nytte og en innsats? Hva er x og hva er y? Bruker alle
det feil?

La oss heller unngå problemet. Når vi snakker om læringskurve, er vi interessert
i den følelsesmessige prosessen rundt å læring av et tema. Dette kan vi beskrive
godt og konsist!

> Emacs har en krevende læringskurve
> Emacs har en læringskurve med skyhøyt takes

Lett å forstå, ikke sant?

* Grad av kjenthet                                                 :noexport:

Merk: Dette handler om konseptet ferdig/uferdig som skala; ikke om
"ferdigheter"; "ting du kjenner prosedyren for å gjøre".

Kunnskap er under kontinuerlig behandling. Det er viktig å vite hva som er
fastsatt, som man kan stole på, og hva som er uferdig.

Tradisjonell løsning:
- Sentral autoritet erklærer hva som er fakta
- Desentralisert miljø bidrar til "det som mangler" i en stor haug av kunnskap,
  hvor alt er uferdig som standard.

Dette skalerer ikke. Forslag:

- Alt er artikler.
- Artikler har en "ferdighetsgrad".
- Alt starter med "ferdighetsgrad" 0.
- Når vi reviderer, kan vi øke ferdighetsgrad.
- Hvem som kan promotere til hvilken ferdighetsgrad kan styres.
- Revisjoner øker ferdighetsgrad. Kjenthet? Prosent?

Vanskelig å sette kjenthet. Relativ kjenthet? 

Dropp kjenthet som et tall.
Kjenthet som skala:
Ukjent -- Vurdert -- Vurdert sterkt -- Kjent.
Konservativ.

Merk: det er meget vanskelig å si hvilken grad av kjenthet noe har. Men det kan
brukes til kommunikasjon. "Pass på å ikke gjøre for mye avhengig av dette; er
ennå ikke helt gjennomtenkt". Vanskelig grensesnitt mot ansvar. Vil ikke ta
ansvar for dette, så "sier bare at det er ukjent".
