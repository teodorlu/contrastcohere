#+TITLE: Ting Teodor tenker
#+AUTHOR: Teodor Heggelund
#+LANGUAGE: nb_no
#+OPTIONS: toc:nil num:nil html-postamble:nil

# Dette er en kommentar uansett hvor den står. Som Python :D

* COMMENT Meta
Dette kapittelet er litt metadiskusjon. Hvordan bør *dette* gjøres?

Siden kapittelet er en COMMENT, blir det ikke med under eksport.
** Tittel
Alternativ tittel: Jeg skriver, jeg tenker. (Litt feil småpirk; ikke jeg skriver
altså tenker jeg, men jeg skriver, så jeg kan tenke andre tanker)

Latin:
- Cogito :: Jeg tenker
- Scribo :: Jeg skriver
- Ergo :: Ergo, derfor
** Bytt ut "du"-referanser med noe bedre
Inntrykket er for dårlig. Når jeg skriver "du", dytter jeg for mye ansvar over
på deg. Det bør jeg ikke gjøre.

/Min/ tekst, /jeg/ tar ansvar!
** Vurder eksport
Forskjellige muligheter her.
*** Direktekonvertering
Org -> Markdown -> Jekyll?

Gode egenskaper:

- Skrive i Org er en meget god opplevelse
- Jekyll gjør det ryddig å finne hver enkelt post.

Mange lag er problematisk. Ønsker å ha hver post på sin egen side ved eksport.
*** Ut-inn
Hva er ut-inn? Timeglass?

1. Behagelig format (Org)
2. Fleksibelt format (JSON)
3. Behagelig format (HTML? Elm?)

Dette er en refleksjon over følgende:

- Vi vil ha det behagelig når vi utvikler
- Dataen bør lagres standardisert
- Vi vil ha det behagelig når vi leser.

Implisitt; bjørnafjorden:

1. Behagelig FEM-modellering
2. Generell lagring i tabeller
3. Behagelig printing av data

Noen punkter:

- I datalaget bør vi ikke ha avhengigheter
- Over- og underlaget bør være så godt som mulig isolert
- Muliggjør utbytte av frontends, eventuelt supplerende frontends.
** Nyttige ting
Snippets om hvordan å sette inn blokker:

| Nøkkelord | Effekt                                |
|-----------+---------------------------------------|
| s         | #+BEGIN_SRC ... #+END_SRC             |
| e         | #+BEGIN_EXAMPLE ... #+END_EXAMPLE     |
| q         | #+BEGIN_QUOTE ... #+END_QUOTE         |
| v         | #+BEGIN_VERSE ... #+END_VERSE         |
| c         | #+BEGIN_CENTER ... #+END_CENTER       |
| l         | #+BEGIN_EXPORT latex ... #+END_EXPORT |
| L         | #+LATEX:                              |
| h         | #+BEGIN_EXPORT html ... #+END_EXPORT  |
| H         | #+HTML:                               |
| a         | #+BEGIN_EXPORT ascii ... #+END_EXPORT |
| A         | #+ASCII:                              |
| i         | #+INDEX: line                         |
| I         | #+INCLUDE: line                       |

Mer info på [[http://orgmode.org/manual/Easy-templates.html#Easy-templates][nettsiden til org-mode]].
* Velkommen!

Teodor, /Januar 2017/.

Hei! Jeg heter Teodor. Trivelig at du vil lese hva jeg har skrevet! Foreløpig er
det ikke mye her.

Tanker bak å ha en blogg:
- Tanker går gjennom en prosess. Først er de uferdige, ufullstendige og skjøre.
  Senere blir de bedre. Før de har vært gjennom litt prosess er de ofte lite
  nyttige for andre. Å skrive ned tanker kan bistå i en slik prosess.
- Noen ideer må bare ned med en gang, ellers blir de borte!
- Gamle ideer kan komme til nytte lang tid etter de er tenkt. Da er det lurt å
  skrive ned!
- ... og ved alt alt sammen er helt åpent, bør jeg da inderlig gjøre en OK jobb
  -- ellers blir det pinlig.

Så hva kan du forvente å se her?

Alt er filosofi. Så dette er en filosifiblogg. Er det sånn den bør
kategoriseres? Nja. Ikke fryktelig nyttig. Så er alt annet. Da gir det ikke
særlig mye informasjon.

Noen temaer som går igjen:

- *Epistemologi*. Hva vet vi? Hva vet vi ikke? Hvordan bør vi forholde oss til
  hva vi vet og ikke vet?
- *Systemer*. Hvordan henger ting sammen? Utvikling blir ofte kalt
  /system/utvikling, ikke helt uten grunn. Systemteori behandles i
  utgangspunktet uavhengig av systemutvikling, og er et spennende fagfelt.
  Hvordan oppfører ting seg når det er satt i system? Hvilke kvalitative
  forskjeller er det på et individ og et system av individer? Hvordan er et
  system forskjellig fra summen av individene?
- *Utvikling*. Jepp, jeg er utvikler, jess, jeg ser verden gjennom en utviklers
  øyne. Så her kommer det ting relatert til utvikling!

* Grad av kaos

Teodor; /Februar 2017/; under /entropi/, /prosjektledelse/, /formidling/.

Konteksten vår er alltid til en viss grad kaotisk eller ryddig. Hva skjer da med
tingene rundt oss? Går de mot orden eller mot kaos? Ofte avhengig av person og
situasjon. Noen er ryddige, andre er rotete. Noen ganger skal vi legge
fundamentet for et langvarig programvareprosjekt, og andre ganger skal vi skrive
en snutt for å løse en enkeltoppgave.

Vi velger oss alle sammen en grad av kaos å arbeide i. Journalisten med all
informasjonen han jobber med spredd over hele pulten. Professoren med stabel på
stabel av åpne bøker. Prosjektlederen med det strøkne skrivebordet, og alt satt
i rett perm. Jeg mener ikke det finnes en ideell grad av kaos -- selv om vi
skulle ønske oss det. Er det ikke lett å ønske at vi hadde "litt mer struktur"
på det vi driver med? Struktur kommer med en kostnad. Det er vanskeligere å
tenke på ting som ikke passer inn i strukturen. Når andre skal kunne forstå hva
vi jobber med er imidlertid struktur alfa omega. Struktur kapper informasjonen i
nyttig og unyttig, og det er lettere å noe når nyttig er klart og tydelig
adskilt fra unyttig. Hva om streken er tegnet litt feil; om vi ved et uhell har
plassert nyttige og unyttige ting i feil bunke? Spiller liten rolle; rekkefølgen
av ting lært blir kun litt forskjellig.

Grad av kaos er et nyttig utgangspunkt for vurdering av programmeringsspråk.
Noen programmeringsspråk påtvinger innsats for å holde orden. Disse er ofte
statisk typede:

- *Haskell* krever at vi holde typene våre i orden. Grensesnitt må defineres og
  være klare, slik at de kan typesjekker.
- *Java* krever at vi organiserer koden vår i /klasser/. Klassifisering for
  orden! Dette fungerer meget bra når klassifisering er hva vi trenger. For
  andre abstraksjoner kan det bli vanskelig. Klasser er i tillegg en mer rigid
  abstraksjon enn typer. Vi må da enda tidligere vite hva vi egentlig lager,
  ellers må vi gjøre store endringer seinere.
- *COBOL* var et tidlig forsøk på å få forståelig kode, og oppmuntre til
  skriving av dokumentasjon.

Andre språk gir frihet. Disse er det gjerne raskere å komme igang med, men gir
en større kneik å klatre når ting begynner å bli stort. "Hva mente jeg egentlig
her?" er noe man /tvinges/ til å besvare tidlig i språk med høye krav til
konsistens og struktur. Å se inkonsistenser tidlig kan gi muligheten til å endre
designet tidlig, og således fikse tidlig uten å grave sin egen grav. På den
andre siden er det stor verdi i frihet når man utvikler en idé. Jo raskere man
kan gå, jo flere runder feedback kan man få kjørt. Å slippe "avbrekk" er en god
ting.

- *Python* er fantastisk lett å komme i gang med. Alle filene du skriver kan
  kjøres direkte, og feedbacken fra kjøring kan bli kvikk. Verktøy som
  [[https://github.com/donkirkby/live-py-plugin][live-py-plugin]] hjelper i tillegg godt til.
- *Clojure* har jeg kommet i gang med i det siste, og erfaringen med feedback er
  meget god. Så god at den kan bli ytret som et problem, for når utviklingen
  raser unna, kan det bli opprydningsarbeid....

* JavaScript -- takk for all fisken

Teodor; /Februar 2017/; under /utvikling/, /programmeringsspråk/,
/funksjonell-programmering/.

Alternativ tittel: Takk til Javascriptutviklerne, som har grepet dagen og gjort
verden bedre. Om du foretrekker denne: tenk /dere/ når du leser /du/ under.

Så vi liker å fokusere på det som suger med JavaScript. Eller de gode bitene.
/Hvordan er språket?/ Her kommer et litt annet spørsmål: /Hva er effekten av
språket?/

1. Funksjonell programmering

   Javascript har vært funksjonelt siden starten. Hadde vi hatt funksjonelle
   egenskaper i Java og C# i dag om det ikke var for JavaScript? Hadde
   funksjonelle språk blitt vurdert? Ville vi fått ting som LINQ?

   Det har vært forsøk på å få til dette siden 1960, og du klarte det.

   Takk.

2. Funksjonellreaktiv GUI-programmering

   Facebook: du gjør all verdens lugubre greier med dataene mine. Du blander
   sammen reklame og nettverk, og misbruker meg og mine venners rykte for å få
   oss til å forbruke mer.

   På den andre siden har du laget React. Ideen var gammel, men som dere
   gjennomførte den. Fantastisk førsteordenseffekt. De fleste
   javascriptutviklere kan i dag bruke et skikkelig fundament som håndterer
   avhengigheter i GUI. Takket være dere får brukere en genuint bedre
   opplevelse.

   Og sekundæreffektene! Både ideologisk og som en plattform. Ideologisk har
   dere hevet den kollektive standarden for GUI-programmering.
   Meldingsbokssystemer som objekter kan gå og legge seg, og jeg trenger ikke
   akseptere å måtte jobbe med noe sånt igjen. Som plattform og bibliotek har
   dere tatt på dere men grandios arbeidsmengde med de grunnleggende
   byggesteinene. Elm og ClojureScript kan nå løse problemer i sine egne fine,
   isolerte domener, og dytte resultatet ned på dere -- fordi dere lagde React
   som et bibliotek, og ikke som et rammeverk.

   Takk.

3. Språklig frihet

   JavaScript gir enormt mye frihet, og betraktning som en plattform gir i mange
   tilfeller mer mening enn betraktning som et programmeringsspråk. Fordi
   språket legger særdeles få rammer for hvordan ting skal gjøres, har
   biblioteksutviklere fått meget stor frihet. De kan utforske hvordan ting bør
   gjøres. Hadde Javascript heller beveget seg i retning Java, og bare tillatt
   utviklere å gjøre det som i forkant ble betraktet som en strengt god idé,
   hadde plattformen stagnert.

   JavaScript er tidenes språklige R&D-operasjon. Friheten har dyttet ned
   ansvaret for utvikling på programmerere, og ikke språkdesignere. Dette mener
   jeg alt i alt er en god ting! Det har gitt oss fantastisk mange fine
   effekter, selv etter kostnader som en utfordrende læringsprosess og mange
   kaotiske kodebaser.

   Denne tankegangen speiler seg i Lisp-kulturen, særlig i Racket. Betyr det at
   vi heller burde hatt Racket i nettleseren? Nja. Da ville nok aldri alle de
   eksisterende utviklerene blitt med over på JavaScript. Det ser litt ut som
   Java, og fy som skinnet bedrar. Dere har kollektivt bedratt alle som har
   blitt med over på JavaScript-toget.

   Hva er så veien videre? Jeg mener bytecode er uungårlig. JavaScript behandles
   allerede i dag som bytecode av språk som Elm, Clojure, Haskell og PureScript.
   Og hvordan gjør det jobben? Særdeles bra! Ytelse er ofte bedre enn i
   originalspråket. Hva skjer da når vi kan kompilere til bytecode? Jeg er
   spent. Jeg gleder meg til å se WebAssembly komme på banen.

   Takk.

* Abstraher ved behov, ikke før                                    :noexport:

# Her blander jeg to forskjellige ting: (a) at innholdet kommer først, og
# utseendet sekundært, og (b) at abstraksjoner bør innføres når det er /behov/
# for dem; ikke før. Kommenterer denne ut inntil videre.

# Også: det kunne vært fint å snakke litt mindre om personlig erfaring med å
# bygge denne bloggen, og mer om ting folk faktisk bryr seg om.

Teodor, /2017-01-16/.

Abstraksjoner er herlig. Det fyller meg med en god, varm følelse når jeg
introduserer en god abstraksjon som gjør problemet renere. Særlig de som gjør
problemet lettere å forstå. Og gode, varme følelser er fint, eller hva?

Noen ganger skal man ikke abstrahere. For eksempel før man har forstått
problemet. Hvilket problem prøver jeg å løse med blogg? Hvilken motor skal jeg
velge? Vet ikke. Har ikke forutsetning til å vite før jeg har produsert innhold.
Strategi? Produser innhold /først/, abstraher ved behov. (Analogt: programmer
/først/, abstraher ved behov.)

Obs obs: En abstraksjon som går lekk (hurr durr norsk, "Leaky abstraction") har
en grusom effekt på tredjepart som ønsker å bruke koden uten å forstå hver
enkelt lille bit. En lekk abstraksjon er dog ofte et steg mot å lage en tett
abstraksjon. Her er det også en skala; "alle abstraksjoner lekker"; men de som
holder i de fleste tilfeller og gir mer glede enn pine er ofte fine.

Jeg klarer iblant å programmere en løsning før jeg begynner å tenke på mulige
abstraksjoner. Det gir ofte fin kode. Er det mulig  med en blogg? [[http://www.paulgraham.com][Paul Graham]]
har en blog jeg liker, som er helt uten superfancy ting. Dette ville jeg prøve.

Denne bloggen er ett dokument i org-mode som jeg kompilerer til HTML med den
innebygde eksport-funksjonen.

Noen fordeler:
- Kompileringsprosessen er "umiddelbar"
- Lasting av nettsiden er "umiddelbar"
- Ukomplisert. Ingen komponenter jeg ikke forstår -- jeg har full kontroll.

Andre ting jeg liker med prosessen:
- Jeg kan redigere i Org-mode. Org-mode er det nærmeste jeg har kommet slik
  redigering av tekstdokumenter bør gjøres. Her en en [[https://www.youtube.com/watch?v=SzA2YODtgK4][introduksjonsvideo]] til
  org-mode.

Når jeg lagrer filen, får jeg automatisk generert HTML-versjonen. Bruker denne
snutten Emacs Lisp for å få det til:

#+BEGIN_SRC emacs-lisp
(defun toggle-org-html-export-on-save ()
  (interactive)
  (if (memq 'org-html-export-to-html after-save-hook)
      (progn
        (remove-hook 'after-save-hook 'org-html-export-to-html t)
        (message "Disabled org html export on save for current buffer..."))
    (add-hook 'after-save-hook 'org-html-export-to-html nil t)
    (message "Enabled org html export on save for current buffer...")))
#+END_SRC

Kilde [[https://www.reddit.com/r/emacs/comments/4golh1/how_to_auto_export_html_when_saving_in_orgmode/][aaptel på Reddit]].

* Hva er rett abstraksjon?                                         :noexport:

Teodor, /2017-02-20/.

# Dette innlegget blander sammen to problemer:
# - Når skal vi abstrahere?
# - Diskusjon rundt rammeverk og biblioteker.
# Finnes det en rød tråd for å snakke om begge deler i samme kontekst, eller bør
# innlegget splittes i to? Strategi: les gjennom og gruble så lenge ting er
# uklart, se etter en løsning.

Abstraksjon er kjernen i programvareutvikling. Uten abstraksjon kunne ikke
verdien eksistert som den finnes i dag. Kompliserte systemer vi tar for gitt
ville vært praktisk umulig å utvikle. Abstraksjon er å løse problemet én gang.
Abstraksjon er å slippe å tenke over problematikk fra forrige gang fordi den
allerede er /løst/.

** Gode abstraksjoner er ortogonale

Så vi klarer å abstrahere når vi slipper å tenke på problemet neste gang. Dette
klarer vi ikke alltid. Når vi også neste gang må tenke på problemet har vi en
/lekk abstraksjon/. Se teksten til [[https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/][Joel Spolsky]] og videoen til [[https://www.youtube.com/watch?v=gRsyY0kzXfw][Mattias Petter
Johansson]] for mer om abstraksjoner som går lekk, på engelsk.

/Effekten/ av en abstraksjon som går lekk er altså at vi må dykke ned i
detaljene vi egentlig skulle vært isolert mot.

Men hvorfor får vi abstraksjoner som går lekk? Jeg vil trekke fram
/ortogonalitet/. Mange kjenner konseptet i kontekst av 2D-koordinater. To linjer
er ortogonale hvis de er vinkelrette på hverandre. Hva fører dette til?

#+BEGIN_QUOTE
/Linjen A er ortogonal på linjen B dersom projeksjonen av bevegelse på A ikke
gir bevegelse på B/
#+END_QUOTE

Ortogonalitet er altså et mål på uavhengighet. En abstraksjon bør løse /ett/
problem, uavhengig av de andre. I matematikk snakker vi ofte om å finne
egenvektorene til et system. Generelt: vi har laget en /ortogonal/ abstraksjon
når den fungerer uavhengig av endringer i resten av systemet.

Påstand: Når vi skriver et bibliotek i stedet for et rammeverk, tvinges vi til å
lage en abstraksjon som i større grad kan kombineres (komponeres) med andre
abstraksjoner. /Biblioteker blir lettere ortogonale enn rammeverk./

** Premisser for et godt rammeverk

Den direkte effekten av abstraksjoner er hvordan hvordan vi bedre kan løse det
spesifikke problemet abstraksjonen er laget for å hjelpe oss med. Så kan vi
begynne å tenke på hvordan abstraksjonen påvirker helhetsbildet. Gjør
abstraksjonen vår det vanskeligere å legge til ekstra funksjonalitet? Blir det
vanskeligere å bruke andre abstraksjoner? Her er forskjellen mellom
/biblioteker/ og /rammeverk/ sentral:

- Et *bibliotek* gir komponenter som vi selv kan sette sammen, som Lego.
- Et *rammeverk* definerer prosessen, og lager "former" der vi kan plugge inn
  våre egne komponenter.

Hvorfor oppstår rammeverk? Gode rammeverk er det naturlige resultatet av mange
iterasjoner på liknende problemer. En god prosess er funnet, og "formene" hvor
tilpasning kan plugges inn er veldefinert. Et godt rammeverk kommuniserer i
tillegg kunnskap om problemet. Basert på lang erfaring om problemet, kan et godt
rammeverk inneholde mye informason som ellers er taus.

Når kan bruk av rammeverk bli en begrensning? I forrige avsnitt gjør jeg noen
antagelser som ikke alltid stemmer:

- Rammeverket har gjort gode, korrekte designvalg
- Rammeverket løser samme problem som du har
- Problemet er statisk; problemet endrer seg ikke over tid
- Rammeverket er en perfekt løsning uavhengig av progresjon i problem- og
  løsningsforståelse; det er ikke behov for å endre prosessen etter hvert som
  forståelsen blir bedre.

** Et alternativ til rammeverk

- Funksjonalitet i et bibliotek
- Forslag til struktur for sammenkobling av komponenter separat:
  - i dokument?
  - Som en mal til bygg-verktøy? lein-my-arch-using-some-lib?

** Effekten 

#+BEGIN_QUOTE
Valg av feil abstraksjon blir kun et problem når vi eksponerer abstraksjonen vår
som et rammeverk, og ikke som et bibliotek. Altså når vi gir brukeren mulighet
til å plugge inn sin egen kode i midten. Vi kan maks bruke ett rammeverk om
gangen! Når vi derimot har eksponert abstraksjonen vår som et bibliotek, setter
vi ikke globale føringer for hvordan "ting skal gjøres", og vi kan lett bruke
flere biblioteker på en gang. Tenk bibliotek kontra bokklubb.
#+END_QUOTE

[[http://tomasp.net/][Tomas Petricek]] har skrevet spennende innlegg om hvorfor han [[http://tomasp.net/blog/2015/library-frameworks/][ikke liker rammeverk]]
og om hvordan å bygge opp rammeverk som [[http://tomasp.net/blog/2015/library-layers/][små biter som kan settes sammen]].

** Abstraksjon som rammeverk.
- Én abstraksjon er tillatt.
- Styrer måten ting skal settes sammen på

** Abstraksjon som bibliotek.
- Mange abstraksjoner er tillatt.
- Gir komponenter som kan kobles sammen på mange forskjellige måter.

Ref: "Når ikke lenger en person skal gjøre alt".

* Teknologi og tema                                                :noexport:

- Innhold i Org. Søkbart, sammenliknbart, tilgjengelig
- Presentasjon med minimalt tema
- TOC til venstre?
  - Ideelt: implementere Org-navigasjon + hjkl i treet.

* Når ikke lenger en person skal gjøre alt                         :noexport:

Delegering er vaaanskelig:

- Ting blir bra fordi du jobber hard med detaljer
- Om du "jobber hard med detaljer når du delegerer" vil du drive personene som
  jobber med deg fra vettet.
  - De gjør en dårligere jobb,
  - Tar ikke ansvar,
  - Tar ikke initiativ
  - ... og du er fremdeles tynget med mental last.

Intenst ansvar kan gjøre at resultatet blir bra. Det kan også forhindre andre i
å ønske å bidra.

Utfordring: dele på arbeidet med Elm-kurset. Ser bra ut! Var vanskelig først,
lettere etter hvert. Lettere å komme inn når noe er litt gjennomtenkt og man har
noen referanser. Tror det gjelder de andre på teamet.

Følelsesmessig: Å ikke lenger ha kontroll. Å delegere er å miste kontroll, /med
vilje/. Hvem ved sine fulle fem går med på noe sånt???

Nå er folk litt forskjellige på denne biten. Noen har null problemer med å
delegere, fordi de ganske enkelt ikke bryr seg. "Ditt ansvar, dust.". Andre har
svære problemer med å delegere fordi de ikke klarer å gi slipp på ansvaret.

Merk: noen ganger må man hoppe i det uten å ha kontroll. Andre ganger er det en
helt tullete avgjørelse å slippe styringen, og man får krise når ting kunne gått
bra.

Eller: /ledelse som bibliotek/; ikke rammeverk.

To kategorier:

1. Ledelse under forutsetning om at hva jeg vet er alt som er relevant
   - Hierarki-basert
2. Ledelse under forutsetning om at jeg ikke vet alt
   - Nettverk-basert

To typer verditilføring:
- Tjenester. Du kan spørre meg om dette, ...
- Struktur. Vil følger alle /denne/ prosedyren, ... -> kohesjon -> verdi

Fakta + forslag:
- *Fakta*: her er informasjon som kan være nyttig.
- *Forslag*: ut ifra min erfaring ville jeg begynt med en prosedyre som ser slik
  ut. Hvis du ikke veit hvordan du kan starte, kan dette være en god ting.

Fakta og forslag/erfaring/prosess fyller to forskjellige roller:
- *Fakta* booster nytten av resonnering (analyse)
- *Erfaring* gir mulige direkteløsninger (intuisjon)

Personlig utfordring: tilbakemelding når noe ikke er godt nok. Jeg misliker å gi
negative tilbakemeldinger, hovedsaklig fordi de kan hindre engasjement,
individualitet og evne til å ta egne valg og "gjøre det beste". Dette er nok en
treningssak.

* Typer eller ikke?                                                :noexport:

Typer er en mulighet for en /meget tett/ feedbackløkke. Denne sikrer konsistens,
og bidrar til kohesjon og arkitektur.

Fjernes typer, får man mulihet til å designe et friere språk. Jeg er særlig fan
av Clojure sin HTML-DSL, som er mer behagelig å skrive enn HTML i seg selv.

(Elm gjør et spennende forsøk, og Haskell/halogen er heller ikke verst å
bruke).

Clojure: 

* Lærbare grensesnitt                                              :noexport:

Bret victor. Mye å hente her?

Gode grensesnitt er lærbare. De eksponerer sin egen mekanikk og oppgave, og lar
brukeren lære hva som gjelder av kausalitet for det aktuelle problemet. Gode
grensesnitt lærer i tillegg brukeren om /problemet/.

Lærbar programmering? Læringsdreven programmering? La andre lære kildekoden din?
Dokumentajonen skal være en prosess til å forstå resten.

Litt forskjellige vinklinger:
- Et lærbart grensesnitt er et grensesnitt hvor brukeren automatisk lærer
  hvordan han kan bruke det uten store steiner i veien.
  - Kontinuerlig bruk gir kontinuerlig forbedring
  - Trenger ikke slå opp i ekstern dokuementasjon
  - Læringen flater ikke ut over tid selv om man ikke dypper laaangt ned i
    dokumentasjonen.
- En lærbar kodebase er
  - Mulig å komme i gang med relativt fort, ingen enorm inngangsterskel
  - Når du først er inne er det lett og naturlig å bli bedre, flinkere, lett å
    navigere
- Et lærbart miljø (lærbar kultur) gir deg
  - En mulighet til å bidra tidlig
  - Kontinuerlig introduksjon til nye temaer, konsepter og ellers taus kunnskap
  - Lar deg bidra tilbake (fold onto self) når du lærer noe, og denne kunnskapen
    blir igjen tilgjengelig for andre
    - Kontroll, frihet og lærbarhet: En wiki gir frihet og lærbarhet, ikke
      kontroll. Trenger rykte og fellesnevnere. Dust sier noe som er usant?
      Trekk diskusjonen inn i rett forum. Du kan ikke bare bestemme hvordan ting
      /er/, det må tas med relevante personer. Trekk info tilbake til "draft";
      sett state til "diskuteres, er uferdig".

(Notat: fiks "du" / "han" / "vedkommende" -- innfør konsistens)

* La feedback drive utviklingen din                                :noexport:

eller "Hvilken feedbackløkke vil du ha"?

Feedback er den største driveren til læring. Vi lærer gjennom tilbakemelding.
Som kunnskapsarbeidere er dette vitalt. Vi sitter ikke og gjør én ting gjennom
livet, vi lærer stadig nye ting. Når du velger deg verktøy (teknologi) for å
løse en kunnskapsbasert utfordring bør derfor feedbackløkken du velger deg stå
sentralt i valget av verktøy (teknologi).

Jeg har i det syste hatt mye moro med live-programmering i Python. ~live-py~ er
en utvidelse til Eclipse og Emacs som kjører live-evaluering av kode mens du
programmerer. Og det går fort. Hvor ofte tester du koden din? Hvor ofte må du
tenke deg om for hva du egentlig får inn her, og hva du kan gjøre med det?
Live-py lar deg først definere hva du skal operere på av data, så får du se i
sanntid hvordan denne dataen snirkler seg gjennom programmet ditt.

~SPC m l~!

<<gif med live-py>>

Hva det egentlig er vi løser som utviklere er ikke alltid så godt definert. Jeg
jobber med styrkeanalyser, og er heldig her: Hvis svaret mitt er matematisk
korrekt, er det som regel nyttig. Innen mykere felt er problemet vanskeligere.
Vi vil tilføre verdi, hva nå enn det skulle si. Da er ikke lenger den
matematiske definisjonen særlig nyttig, men vi vil heller ha nærhet til
brukergrensesnittet vi lager. Figwheel gjør en veldig god jobb.

<<gif med Fighweel>>

~try-elm~ med unger er fantastisk. Gif?

Scratch fungerer på denne måten ut av boksen. Scratch er dessverre meget langt
fra hva vi må bruke av verktøy i hverdagene våres, og overgangen til teknologi
som faktisk kan løse det aktuelle problemet kan/vil bli smertefullt.

Abstrakte problemer er en annen sak. Typer. Feedback til hjernen? Å skrive ned
som å resonnere? Å definere problemet så det kan /sees/ er kraftfullt. Om du kan
skrive det ned i rett språk (Norsk, Matematikk, kode, tegninger, ...), vil det
hjelpe tankeprosessen i rett retning.

* Fryktdreven utvikling                                            :noexport:

Frykt gjør at du ikke tør å teste. Frykt gjør at du aldri får tilbakemelding.
Fryktdreven utvikling er antitesen til feedbackdreven utvikling. Redsel gjør at
vi ikke lærer. Redsel for å gjøre feil. Grusomt.

* Hva kan jeg?                                                     :noexport:

Tre ting jeg bryr meg om:
- Informasjonsteknolog :: Utvikling, programmeringsspråk, teknologier
- Sivilingeniør* :: Statikk, elementanalyse, likevekt, ikkelineariteter,
                    dimensjonering av stål og betong
- Undervisning :: Formidlingsevne; studentassistent, Lær Kidsa Koding

Kryssrelasjonene er særlig spennende. Lærbar programmering? Programmering for
sivilingeniører? Hvordan kan sivilingeniører lære programmering? Her føler jeg
potensial!

*Er fullt klar over at man kan få en sivilingeniørgrad uten mekanikk, men jeg
sliter med å finne et bedre uttrykk for kulturen for rasjonalitet, sannhet og
gode løsninger jeg ser i sivilingeniøren. Det er denne kulturen som interesserer
meg, ikke nødvendigvis momentdiagrammene eller likevektslikningene. "En
naturlovenes forekjemper i et samfunn av kaos"?

* "Folding onto itself"                                            :noexport:

Konsept med kraft. *Selvdreven feedback-loop*. Selvforsterkenede feedback-loop.
Selvforsterkende effekt. Resonnans. Kraften av frihet.

Eksempler:
Programmerere har mer potensial til "selvbretting" enn mange andre yrkesgrupper.
De har muligheten til å lage sitt eget miljø:

- Programmet du lager former hva som er mulig. Design utvikler seg til å kunne
  utrrykke ideer. Når du må gjøre noe tungvindt er det alltid mulig å gjøre det
  smartere. Du kan tilpasse miljøet ditt (kodebasen) til å være utvidbar i den
  retningen du ønsker.
- Byggsystem. Det trenger ikke, og bør ikke være manuell klikking involvert for
  prosedyrer relatert til hva du driver med. Skriver du byggsystemet ditt selv,
  kan du velge hvordan ting skal skje. Datamodellering -> prosedyremodellering
- Verktøy. Emacs er kjerneeksempelet. Du kan i tillegg til å modellere og
  videreutvikle (a) kodebase og (b) byggsystem; videreutvikle (c) editoren din.
  Sirkelen er full. Nær-religiøsitet er oppnådd.

Ingeniører er mer begrenset i hva de kan gjøre. Verktøyene som brukes er direkte
begrensende, og motvirker enhver form for selvbretting:

- Ting er de-facto engangs, gjør ditt-gjør datt. De prosedyrene det er mulig å
  modellere, er mulige /gjennom ekstra arbeid/. GUI-formatet på alt mulig ellers
  gjør det vanskelig å løse problemer én gang.
- Ting er skjult. Jeg har de facto ikke muligheten til å se hvordan ting
  fungerer, og kontrollere hvordan "ting skjer inni". Hvorfor ikke? Ingen god
  grunn.

  Kontraeksempel: abaqus ved bruk av inputfiler gir mer kontroll enn GUI. Det
  gir modularitet, og muligheten til å omorganisere, trekke ut felles logikk.
  Det er imidlertid ikke mulig å modellere /prosedyrer/. Disse er hardkodet.
  Lekse fra Unix.

Konseptet med bibliotek over rammeverk er nært beslektet. Parsec i Haskell er et
/bibliotek/ for parsing, og ikke et rammeverk, som lar brukeren /kombinere og
komponere/ en parser, i stedet for å kreve at paring skal gjøres *akkurat slik*.
Spacemacs sliter litt med at ting er for tett koblet. Det er vanskelig å forstå
helheten, selv om det er en meget god helhet. (Dette er ikke krass kritikk av
Spacemacs, men en anerkjennelse at læring av Spacemacs blir vanskelig. Det er
imidlertid /mulig/ å forstå hvordan det fungerer, gitt at man klatrer en
krevende læringskurve.)

* /Utfordrende/ læringskurve, ikke /bratt/ læringskurve            :noexport:

I dag skal jeg være pedantisk. Jeg føler jeg må.

... eller bør vi bare si "krevende læringsprosess"?

Hva er en bratt læringskurve? For å svare på spørsmålet må vi vite aksene. Er en
læring og en tid? Er en nytte og en innsats? Hva er x og hva er y? Bruker alle
det feil?

La oss heller unngå problemet. Når vi snakker om læringskurve, er vi interessert
i den følelsesmessige prosessen rundt å læring av et tema. Dette kan vi beskrive
godt og konsist!

> Emacs har en krevende læringskurve
> Emacs har en læringskurve med skyhøyt tak

Lett å forstå, ikke sant?

Hva tenker jeg om "han som sa at Lisp bare er tull fordi det er vanskelig
("uleselig", "uhåndterbart") på YouTube? "Skriv om alt til Perl"?

- Enhver kodebase skrevet av én person kommer til å være bygget opp på en annen
  måte enn en kodebase skrevet i konsensus
- Fordel: stor grad av kohesjon
- Fordel: (kanskje) få feil
- Ulempe: stort krav til eksakt samme kompetanse som vedkommende har
- Ulempe: liten grad av tilbakemelding på lærbarhet

Felles kodebaser tvinges til å bli lærbare uten reimplementering.

* Grad av kjenthet                                                 :noexport:

# Hvordan relaterer dette til "grad av kaos"? Noe å lære?

Merk: Dette handler om konseptet ferdig/uferdig som skala; ikke om
"ferdigheter"; "ting du kjenner prosedyren for å gjøre".

Kunnskap er under kontinuerlig behandling. Det er viktig å vite hva som er
fastsatt, som man kan stole på, og hva som er uferdig.

Tradisjonell løsning:
- Sentral autoritet erklærer hva som er fakta
- Desentralisert miljø bidrar til "det som mangler" i en stor haug av kunnskap,
  hvor alt er uferdig som standard.

Dette skalerer ikke. Forslag:

- Alt er artikler.
- Artikler har en "ferdighetsgrad".
- Alt starter med "ferdighetsgrad" 0.
- Når vi reviderer, kan vi øke ferdighetsgrad.
- Hvem som kan promotere til hvilken ferdighetsgrad kan styres.
- Revisjoner øker ferdighetsgrad. Kjenthet? Prosent?

Vanskelig å sette kjenthet. Relativ kjenthet? 

Dropp kjenthet som et tall.
Kjenthet som skala:
Ukjent -- Vurdert -- Vurdert sterkt -- Kjent.
Konservativ.

Merk: det er meget vanskelig å si hvilken grad av kjenthet noe har. Men det kan
brukes til kommunikasjon. "Pass på å ikke gjøre for mye avhengig av dette; er
ennå ikke helt gjennomtenkt". Vanskelig grensesnitt mot ansvar. Vil ikke ta
ansvar for dette, så "sier bare at det er ukjent".

** Skal grad av kjenthet eksponeres?

Forskjellige personer har forskjellig behov til kjenthetsgrad. Bør alle trenge å
ta hensyn til dette? Når jeg skriver en tekst, skal jeg formulere meg sikkert på
kun det jeg anser som sikkert, eller skal jeg forutsette at leseren (som ofte
stemmer) er litt mindre interessert i den epistemologiske biten, og bare vil
kunne forutsette "det beste vi vet"?

Personlig: veldig mange bare skummer over og dropper usikkerhetsformuleringer.
Sier at "sånn er det, sånn skal det være". Vil sette agenda, sette virkelighet,
mutere andres oppfatninger. Siden dette er vanlig, er man ofte vant til å være
kritisk til andres påstander.

Kritisk formulering:
- Mer eksakt
- Mindre passende mot prosa-form
- Lite politisk, lite populistisk
- Blir ofte verbost. Teksten full av "kanskje", "trolig", "sannsynligvis",
  innholdet drukner lett

"Det går sikkert greit"-formulering:
- Bedre flyt i tekst
- Passer godt overens med annen prosa, tekst
- Se på hele teksten monadisk under usikkerhet? Konklusjonene underveis er
  basert på usikkerhet, returnerer noe som er litt mer usikkert?

#+BEGIN_SRC haskell
data Statement a = { ... }

instance Monad Statement where
  return = assert
  precondition >>= reasoning =
    let assumes = getAssumes precondition
        conclusion = reasoning assumes
    in  conclusion
#+END_SRC

/geeklevel veryhigh.

* Dokumenter som hierarkier                                        :noexport:

Sekvensielt dokument: prosa.
Hierarkisk dokuemnt: fakta. Kunnskapstre. Hvorfor i all verden kutter vi vekk
strukturen? Mulig å beholde denne og navigere med den!

Mer generelt: Kunnskapen vår er ca et tre, reelt en graf. I alle fall ikke en
liste! Bedre å bruke et tre til å representere enn en liste. Wikipedia er et
godt eksempel på kunnskap-som-graf. Lenker, diverse indekser. Konsepter er etter
ord (navn). Ved duplikater: lag indeks, referer. Hash-map: Etter hash. Ved
duplikater: lag lenket liste, populér "det under".

Org-mode gjør dette heeelt fantastisk. Så lesbart! Så navigerbart! Mååå bruke!
Vise! Dele! :D

Ting som er gjort fint:
1. Synlig dokumenthierarki, forståelig
2. Semantisk betydning av hierarki, som gjør at koden kan refaktoreres
3. Plain-tekst-representasjon, så dokumentet kan være i versjonskontroll og
   redigeres (leses) av andre editorer
4. ... selv om org-mode i seg selv gjør dette meget mer behagelig automatiserte
   redigeringsverktøy som drar nytte av strukturen

* Informasjonsflyt i dokumenter                                    :noexport:

Hva er en +god+ behagelig måte å representere dokumenter på?

- Behagelig å skrive dokument
- Enkel kompilering, rask feedback på resultat
- Behagelig å lese dokumentet.

Som kan løses ved følgende:

- Skriv dokumentet i formatet du ønsker
- Sørg for at det finnes en skikkelig parser som kan gi deg dokumentet i en
  hierarisk datastruktur
- Skriv din egen eksport av datastrukturen

Lær av Pandoc (men Pandoc har i tillegg mange typer inputstruktur).

** Eksempel: Org-mode til HTML

1. Skriv i org-mode, som er behagelig
2. Bruk innebygget parser til å tolke dokument
3. Bruk innebygget HTML-generator til å lage noe en nettleser kan lese

Pluss: enkelt
Minus: én svær HTML-side som kan være problematisk å linke til og navigere i.

** Eksempel: Org-mode til JSON + viewer

1. Skriv i org-mode
2. Parse med Pandoc
3. Skriv ut JSON
   Bonus: Er ikke så alt for mye, så JSON bør holde fint.
4. Lag webapp for å tolke og søke rundt i JSON.
   F.eks. CLJS eller Elm. Søk, collapse, tree view.
   Trenger bare shift-tab for å toggle collapse all og tab for toogle collapse
   current.

* Overlegenhet                                                     :noexport:

"Jeg klarer ikke forklare dette".

Forutsetning: jeg har rett, du tar feil, du skjønner ennå ikke faktaen som er
inni hodet mitt. Stemmer dette? Bør det modereres? Hmm, spørs.

Om man i "dette" legger "dette som er i hodet mitt" er det uproblematisk. Hvis
"dette" betyr "denne etablerte faktaen", er saken en annen.

Filosofisk: Bør jeg forutsette at jeg har rett? Bør jeg anerkjenne at jeg
oprererer i en kontekst; en kontekst som kan være feil? Kanskje ikke? Hva er
mest nyttig? Noen ganger bør vi oppmuntre andre til å tenke selv. Nesten alltid,
kanskje? Andre ganger snakker vi med personer som "bare vil ha svaret" for å
kunne gjøre noe annet. Disse personene har helt andre behov.

* Strategi for bloggen                                             :noexport:

Bloggen fungerer som to ting:
- En tenketank med mildt kaos
- Et arkiv, et oppslagsverk, klart for andres oppmerksomhet

Merk: det er forskjellige grunner til ikke å dele informasjon:
1. For å skjule egne imperfeksjoner fra offentligheten
2. Som en anerkjennelse at informasjonen er uferdig, og per nå gir forventet
   netto negativ verdi til andre enn forfatteren (eller eventuelt et høyere
   krav; netto positiv verdi til 95 % av leserene)

Håpet er at jeg klarer å balansere 2. på en god måte. Merk: Dette er ikke (per i
dag) ment som et diskusjonsforum, der alle kommer og bidrar med sin bit. Hadde
dette vært publisert på en slik måte ville saken vært en annen.

Kanskje legge ved Gitter-chat? Følger repoet, enkelt, søkbart.

Morsomt, var visst en skala dette også.

* Effektivitet vs kompleksitet                                     :noexport:

Et uendelig problem. Eller formulering? Ikke noe som kan løses, men kanskje noe
det er nyttig å ha en forhold til. Punkter:

- Hvilket nivå som er lønnsomt å legge seg på varierer fra person til person
- Høy kohesjon mellom personer gir gode muligheter til å dele kunnskap;
  informasjon; prosedyrer, gir økt potensiale for kommunikasjon
- Forskjellige personer løser forskjellige oppgaver på forskjellig vis. Det gir
  høyst forkjellige krav til effektivitet. Hva skal settes i system?
- Tidsbudsjett. 
  - Løse én gang nå. Legge inn en innsats nå, og gjøre ting mer effektivt
    seinere.
    - Legg grunnsteiner for systemet nå
    - Bygg forståelse av problemet underveis
    - Bygg muskelminne av problemet underveis
    - Videreutvikle når muskelminnet sitter og problemforståelsen er økt.
    - Aversjon mot ineffektivitet
    - Sier noe om /potensialet/ til et system. Minste felles multiplum?
  - Ta problemer som de kommer.
    - Vær avers mot å innføre nye systemer
    - Kjenn på smerte. Når noe gjør /skikkelig/ vondt, innfør systemet for å
      gjøre det mindre smertefullt.
    - Innfør system kun ved behov.
    - Aversjon mot kompleksitet og terskel
    - Sier noe om /grunnlinja/ til et system. Største felles divisor.

* Hvor dybt må du gå for å komme til selvbretting?                 :noexport:

Relatert: "Folding onto self".

Grad av selvbretting synes et OK mål på grad av tilpasning; grad av kraft. La
oss prøve å evaluere noen verktøy i kontekst av selvbretting.

- Visual Studio: *3/10*. Lag ditt eget språk. Dog gode muligheter for key
  bindings. Sannsynligvis markroer på et eller annet nivå, men man må gjennom en
  masse menyer for å få tilgang. Menyene forhindrer frihet og selvbretting. Du
  kan ikke bruke editoren til å redigere menyene.
- Github Atom: *6/10*. Kan endre editoren i språket du bruker til å skrive
  programmet.
- Emacs: *10/10*. Editoren er kun et tynt skall over funksjonalitet. Ultimat
  selvbretting.
- Java: *5/10*. Kan lage egne prosedyrer og klassehierarkier. Arv kan være
  nyttig. Overloading av funksjonalitet i forskjellige objekter. Problematikk:
  svært verbost, må skrive mye for å få gjort noe. Funksjonsdeklarasjon er
  komplisert. Før Java 8 måtte man ha en klasse. Nå klarer man seg uten. Typer
  må ofte lages selv.
- C#: *6/10*. Litt mer fritt enn Java.
- Haskell: *8/10*. Konsist. Spennende potensial for DSL-er. Bruk av DSL-er
  typesjekker i språket. Implisitt typing gjør ting enda bedre.
- Python: *9/10*. Fullstendig frihet. Hva som følger med er ikke spesielt. Det
  er bare brukt litt vanskeligere deler av språket som man vanligvis ikke
  eksponeres for. Dekoratorer, metaklasser. Mulig å tilpasse til hva man
  trenger.
- Lisp: *10/10*. Det som følger med er en liiten kjerne. Resten kan tilpasses
  til hva man trenger. Rekursjon og funksjonsdeklarasjon er hakket mindre
  elegant enn i Haskell

* Presis eller implisitt?                                          :noexport:

"Korrekt eller behagelig?"

Tommelfingerregel: vær presis. Vær konsis.

Unntak: Noen ganger er implisitt kommunikasjon svært effektivt. Når begeret for
presis kommunikasjon er fylt, kan det fremdeles være noe igjen i den implisitte.

Programmering: /Du må være presis/. Ellers går det ikke.

Tekst som andre skal lese:
- Det er ofte smart å være presis
- Du kan ofte få ekstra mye ut av å bruke implisitte virkemidler
- Ekstra bonus: tenk på hvordan andre tenker på ting. Hvordan kan du gjøre denne
  tenkingen lettere? Bedre?

Eksempel: Blogger. Tematikken er sprikende. Hvis kategorisystemet vårt skulle
vært presist, hadde vi mistet hele mangfoldet, og mesteparten av de kule
tingene.

Felle: Noen ganger er det bare lettere å gjøre det implisitt når du burde gjort
det presist. Ved å gjøre det implisitt leverer du et dårligere resultat, fordi
du ikke har jobba skikkelig gjennom problemet. Du forsøpler kommunikasjonen.

Felle 2: Folk vet forskjellige ting. Andre vet ikke hva du vet. Det du
presenterer som presis informasjon kan være vanskelig å skjønne for andre. Du
kan unnlate å presentere innhold som ikke hører hjemme i en heeelt presis tekst,
som kan føre til at du fjerner innhold som andre har bruk for.

* Korrekt eller deilig?                                            :noexport:

# Spennende hvor mange av disse innleggene som utforsker en kontrast?
# Contrastcohere var kanskje ikke et så alt for dårlig navn, når alt kommer til
# alt. Der er imidlertid på engelsk. Jeg liker å skrive på norsk.

Dagens kontrast: bør du optimalisere representasjonen for noe rent, generelt,
som kan være en fysisk lov; eller bør du gjøre det så behagelig å ta inn over
seg som mulig?

- Dokumenter du sender til andre skal være presentable.
- Dokumenter du skriver for egne formål, for å forstå hva du selv driver med,
  bør være presise.

Eller

- Kilden skal være presis
- Resultatet du leverer skal være presentabelt

Hvor på læringskuven er vi? En første introduksjon bør helle mot behagelig, mens
under kommunikasjon med en ekspert er det verdi i å være presis.

* Ferdig eller ikke?                                               :noexport:

Når skal man slippe ting? Når det er 100 % ferdig? Eller før? Er det OK å fikse
ting etter det har kommet ut? Hva med blogposter? Skal de permanent være som de
var? Bør det være mulig å spole i tid? Det krever litt system. Software FTW.
"Hø, ja det er litt vanskelig. Gi meg en uke."

Hva er målet til teksten? Å hjelpe videre tankevirksomhet? Eller er det å
kommunisere noe til andre? Dette er helt forskjellige mål, som bør gi helt
forskjellige midler. Hva du gjør for egen forståelses skyld er forskjellig fra
hva du både (a) ønsker å formidle til andre, (b) har fått en såpass god
forståelse av at det er hensiktsmessig å formidle, og (c) har fått formulert som
en gjennomført tekst som gir mening i en helhet.

Personlig heller nok jeg mot å slippe ting for sent. Så kanskje en idé å slippe
ting /litt/ før jeg er komfortabel med å gjøre det.

Effekt kan gi et viktig innblikk i når noe "bør slippes". Hva er effekten av
feil informasjon? Hva er effekten av ingen informasjon?

20/80 kan veilede litt her. Mer innsats inn i en oppgave er bra. Men effekten av
innsatsen avtar med tid. Når produktet allerede er veldig bra, blir det ikke mye
bedre av litt mer innsats. Slipp ut til andre når effekten av innsats avtar? Når
effekt derivert på innsats synker merkbart?

* I søk etter en optimal verdensmodell                             :noexport:

Vi løper alle rundt i verden med en forestilling om hvordan verden er. Vi
forestille oss hvordan ting vil kunne foregå. Vi bruker verdensmodellen til å
predikere, og om den suger, så har vi et meget stort problem.

Verdensmodellen vår er statig i utvikling. Vi tar feil, kalibrerer modellen, og
prøver igjen. Så glømmer vi hva vi trodde i utgangspunktet! Fordi vi ikke husker
at modellen vår har vært feil tidligere, stoler vi blindt på modellen når vi
trenger den igjen. Vi dundrer inn i ny feil, og syklen starter igjen.

Spennende tema TODO TODO TODO

* Verdien av isolasjon                                             :noexport:

Isolasjon henger sammen med effektivitet og fokus. Per nå er hele denne teksten
er svær monolitt. Bør den eksporteres som mange små? Søkes gjennom og hver
overskrift på hver sin side? Eller parses inn så den kan tolkes som enkeltsider
av brukeren?

Selv om jeg ønsker å se på alt i én kontekst, er det ikke sikkert at det passer
for alle andre. Verktøyene er svært forskjellige. Å skrive og navigere i
Org-mode kjennes villt forskjellig fra å lese en nettside. Jeg kan operere på et
hierarki.

Personen i den andre enden kommer ikke til å klone repoet for å lese i Org. Det
ville ikke engang jeg gjort. Custom eksport? Kult om vi kan ha alt i én
nettside. Laste informasjonen som JSON og operere på denne? Navigere fram og
tilbake? Er ikke så stor at det blir problematisk å laste hele i én smell. I
alle fall ikke for ren tekst. Det er lite av bilder her foreløpig.

TODO TODO TODO

* Forskere og ingeniørerer                                         :noexport:

- Forskning er *fundamentert*: påstander er fundamentert på ren kunnskap. Ingen
  "skilpadder hele veien ned".
- Ingeniørdrift er *kalibrert*: påstander er sjekket mot effekter og behov.

TODO TODO TODO

* Prefer abstractions that flatten                                 :noexport:

Hierarchies are
- a hard cognitive load
- tedious to write.

Abstractions that flatten hierarchies are often useful.

- Function composition over nested for loops
- Bind (>>=) over nested pattern matching (Haskell)
- Thread (->, -->) over nested function calls (Clojure)

Why? Hierarchies are just sooo general. Not a tight abstraction. Hard to think
about. Flat lists are more neat for the end user.

How to find abstractions that flatten? Not easy. I try to look for really nested
code, then consider if I can break out of this somehow.

Trick: See if the nesting can be expressed as a data structure. The data
structure may be built with composition. In C# you might want objects you can
chain together. In Haskell, you want some infix operator for combination. For
Clojure, you want to stick all your things inside a function/macro handling all
the things.

* Jeg vil ikke ha systemet ditt                                    :noexport:

Prinsipper:

- Verden er blitt så komplisert at det er tilnærmet umulig å vite alt
- Vi takler kompleksiteten ved økende grad av ferdighet i /søk/; hvordan kan vi
  få ut informasjon uten å lære /alt/? Hvordan kan vi finne akkurat hva vi leter
  etter?
- Over Internett og andre asynkrone informasjonskanaler er dette noe vi bare må
  akseptere og omfavne. Hvordan kan brukeren av informasjonen min få vite
  akkurat hva han trenger så fort som mulig?
- Person til person er det mulig å være mer fleksibel. Skjønnsvurderinger kan
  avgjøre hvordan personer kan måtte sette seg inn i noen grunnprinsipper før de
  slippes løs i den store kaotiske verden. Dette er mulig fordi vi kan vurdere
  /hva som trengs/ av grunnkunnskap; i kontekst.

Så hva bør vi egentlig gjøre? For enkle problemer; gjør kunnskap så søkbar som
mulig. Link til den generelle kunnskapen fra den spesielle. Gi eksemplene først,
så kan mottakeren selv få generalisere og lage sitt eget system.

Det går uansett ikke an å sende system og intuisjon direkte fra hjerne til
hjerne (i dag). Vi er avhengig av å lage våre egne systemer. Mitt system
fungerer i min kontekst, og er testet mot denne. Du trenger å løse helt andre
problemer, og for disse kan systemet mitt være helt feil. Eller det kan hende at
du ikke vil ha systemer i det hele tatt; men kun forholde deg til hva du har
sett.

* Klasser til konseptuell abstraksjon                              :noexport:

Klasser skinner til konseptuell abstraksjon. Klasser mapper bra med ting vi ser
rundt oss, og er meget naturlig å bruke til noe som /gjør noe/ med verden.
Eksempel: et objekt som kan leses fra fil, og eksponere diverse egenskaper.
Pakker vi dette i funksjoner får vi ofte en trickle-down effekt av IO -- Hvilke
funksjoner skal operere på data, og hvilke skal lese og styre konteksten vår?
Med klasser blir dette rent; vi har én datastruktur som vi kan operere på og
gjøre ting med; vi kan lese denne fra filer og skrive til filer når vi er
ferdig.

Klasser er en fin måte å gjøre kode du har skrevet tilgjengelig for andre. Det
er lett å forstå hva objekter av en klasse gjør; det passer bra med hvordan vi
oppfatter verden. Dette tror jeg er mye av grunnen til at OO har kommet så langt
i verden.

Når vi skal vedlikeholde vår egne interne kodebase gjelder andre vurderinger.
Hvor lett er det å gjøre endringer? Hvor mye kunnskap forutsettes? Kode klasser
skrives etter mye prototyping; som gjør det mulig å finne den rette
abstraksjonen for et problem. Mesteparten av koden vår er ikke på dette nivået
ennå! Vi skriver nye ting hele tiden, og skal bygge om hvordan delene henger
sammen. Da vil vi ikke måtte skrive om /alt/ hver gang! Rene funksjoner
komponerer bedre enn klasser, men klasser er konseptuelt kompakte.

Klasser er naturlig fine til å gjøre /konfigurasjon/. Vi kan ta flere argumenter
som stiller som styrer hvordan metodene våre oppfører seg i ettertid. Skal vi få
til en tilsvarende god abstraksjon i kode, må vi være lure. Vi vil sannsynligvis
ha et konfigurasjonsobjekt som en ren datatype. Det skal være mulig å spørre om
et standardoppsett som har forutsatt så mye som mulig, og det skal være mulig å
overstyre egne egenskaper. Elm gjør dette svært bra med sin =Record=-type. Vi
kan da eksponere funksjoner som har konfigurasjonen curryet inn, så vi slipper å
gjenta at vi må putte inn konfigurasjonen i alle kallene vi gjør.

At vi eksplisitt må sende konfigurasjonen rundt (som kreves av rent funksjonelle
miljøer) kan rent dumt implementeres med boilerplate; ett
konfigurasjonsparameter til alle funksjoner. Om vi klarer å være litt lurere,
slipper vi unna dette, og kan skille på funksjoner som faktisk trenger
konfigurasjonen og andre funksjoner som kan forbli rene. Vi kan da kun sende
konfigurasjonen til funksjonene som trenger tilgang til konfigurasjonen.

Så hvor ender vi opp? Vi kan lage oss en stige av abstraksjoner:

1. *Rene funksjoner* med argumenter, det enkleste som finnes
2. *Klasser* kan samle opp konfigurasjon og distribuere dette ut til de som
   trenger det
3. *Konfigurasjon i data*, à la =Record= i Elm pluss smarte valg av hvor vi skal
   sende konfigurasjonen vår
4. *Full DSL* som håndterer konfigurasjonen vi vil ha. [[http://tomasp.net/blog/2015/library-layers/][Tomas Petricek]] snakker om
   konseptene bak dette. Se [[https://hackage.haskell.org/package/scotty][Scotty]] (Haskell), [[https://hackage.haskell.org/package/parsec][Parsec]] (Haskell) eller [[https://hackage.haskell.org/package/pandoc][Pandoc]] og
   [[https://hackage.haskell.org/package/pandoc-types][Pandoc Types]] (Haskell) for eksempler på prinsippene i produksjons.

* Timeglassarkitekturen                                            :noexport:

Prinsipper:

- Fleksibel kildeformat
- Fleksibelt målformat
- Interoperabilitet.

Vi burde ha stor fleksibilitet i hvordan vi designer innhold. Samtidig bør det
lett være mulig å "bytte backend"; vi skal ikke knytte oss direkte til en stack.
Dette kan vi få til ved å ha noe særdeles fleksibelt på toppen, som "kompilerer"
til noe lettere.

Anvendt på blogging:

- Org mode er et enormt fleksibelt inputformat
- Eksporter til et mellomformat. Pandoc JSON?
- Visualiser dette standardiserte dataformatet. Kan ende opp som HTML og PDF.

* Meta meta meta meta meta meta STOPP                              :noexport:
Teodor, /juni 2017/ under /abstraksjon/.

Du tenker. Nå tenker du på at du tenker. Når du leser denne teksten, tenker du
da på at du tenker på at du tenker? Hvor mange nivåer oppover kommer du før det
sier stopp? 2? 3? 4?

Ta et steg til siden. Vurder kritisk: "Hvilket nivå bør du legge deg på?" For
noen problemer må du gå så langt opp du klarer. For andre problemer er de høyere
nivåene en distraksjon.

Hva er verdien i å kommunisere hva du ønsker til andre mennesker, relativt til å
kunne uttrykke supergenerelle sannheter? Supergenerell sannhet kommunisert til
to personer, eller noe litt mer konkret som tjue er i stand til å forstå?

Om du er i stand til å abstrahere så langt opp at ingen skjønner hva du mener,
bør du være i stand til å ta steget til siden. Vurder hele stabelen med
abstraksjoner kritisk. På hvilket abstraksjonsnivå er det optimalt å ligge i
dag? Ja, det er spennende å tenke så abstrakt som mulig. Ja, /evnen/ til
abstrakt tenkning kan gjøre utenkelige ting mulig. Det betyr ikke at det alltid
lønner seg å ligge på grensen til det som er begripelig.

Så! Hypotese. Hva skal du gjøre i dag? I dag skal jeg bruke to timer på å gjøre
ting som er helt konkrete.
* Hvor på skalaen skal du legge inn innsatsen?
Kunnskap ligger på en skala. Hvor spesialisert er kunnskapen? Hvor mye
forutsetter den? Hvor mange kjenner til hvordan den fungerer? På en side finnes
informasjon som alle kan forstå seg på, som forutsetter lite. På den andre siden
er kunnskap kun én person sitter på. Hvilken informasjon skal vi trekke ned? Hva
skal vi viderebehandle? Hva er viktig nok til at vi skal bruke tid på det?
